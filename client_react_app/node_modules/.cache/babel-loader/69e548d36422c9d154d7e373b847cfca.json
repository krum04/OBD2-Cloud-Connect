{"ast":null,"code":"import { Component, ContentChild, Directive, ElementRef, Input, NgModule, Renderer, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\r\n * @param {?} value\r\n * @param {?} min\r\n * @param {?} max\r\n * @return {?}\r\n */\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\n\n/**\r\n * @param {?} value\r\n * @param {?=} fallbackValue\r\n * @return {?}\r\n */\n\n\nfunction coerceNumberProperty(value, fallbackValue) {\n  if (fallbackValue === void 0) {\n    fallbackValue = 0;\n  }\n\n  return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\n\n\nfunction cssUnit(value) {\n  return value + \"px\";\n}\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\n\n\nfunction isNumber(value) {\n  return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n\nvar NgxGaugeAppend =\n/** @class */\nfunction () {\n  function NgxGaugeAppend() {}\n\n  return NgxGaugeAppend;\n}();\n\nNgxGaugeAppend.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"ngx-gauge-append\",\n    exportAs: \"ngxGaugeAppend\"\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGaugeAppend.ctorParameters = function () {\n  return [];\n};\n\nvar NgxGaugePrepend =\n/** @class */\nfunction () {\n  function NgxGaugePrepend() {}\n\n  return NgxGaugePrepend;\n}();\n\nNgxGaugePrepend.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"ngx-gauge-prepend\",\n    exportAs: \"ngxGaugePrepend\"\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGaugePrepend.ctorParameters = function () {\n  return [];\n};\n\nvar NgxGaugeValue =\n/** @class */\nfunction () {\n  function NgxGaugeValue() {}\n\n  return NgxGaugeValue;\n}();\n\nNgxGaugeValue.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"ngx-gauge-value\",\n    exportAs: \"ngxGaugeValue\"\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGaugeValue.ctorParameters = function () {\n  return [];\n};\n\nvar NgxGaugeLabel =\n/** @class */\nfunction () {\n  function NgxGaugeLabel() {}\n\n  return NgxGaugeLabel;\n}();\n\nNgxGaugeLabel.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"ngx-gauge-label\",\n    exportAs: \"ngxGaugeLabel\"\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGaugeLabel.ctorParameters = function () {\n  return [];\n};\n\nvar DEFAULTS = {\n  MIN: 0,\n  MAX: 100,\n  TYPE: 'arch',\n  THICK: 4,\n  FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\n  BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\n  CAP: 'butt',\n  SIZE: 200\n};\n\nvar NgxGauge =\n/** @class */\nfunction () {\n  /**\r\n   * @param {?} _elementRef\r\n   * @param {?} _renderer\r\n   */\n  function NgxGauge(_elementRef, _renderer) {\n    this._elementRef = _elementRef;\n    this._renderer = _renderer;\n    this._size = DEFAULTS.SIZE;\n    this._min = DEFAULTS.MIN;\n    this._max = DEFAULTS.MAX;\n    this._initialized = false;\n    this._animationRequestID = 0;\n    this.max = DEFAULTS.MAX;\n    this.type = DEFAULTS.TYPE;\n    this.cap = DEFAULTS.CAP;\n    this.thick = DEFAULTS.THICK;\n    this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;\n    this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;\n    this.thresholds = Object.create(null);\n    this._value = 0;\n    this.duration = 1200;\n  }\n\n  Object.defineProperty(NgxGauge.prototype, \"size\", {\n    /**\r\n     * @return {?}\r\n     */\n    get: function get() {\n      return this._size;\n    },\n\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n    set: function set(value) {\n      this._size = coerceNumberProperty(value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgxGauge.prototype, \"min\", {\n    /**\r\n     * @return {?}\r\n     */\n    get: function get() {\n      return this._min;\n    },\n\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n    set: function set(value) {\n      this._min = coerceNumberProperty(value, DEFAULTS.MIN);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgxGauge.prototype, \"value\", {\n    /**\r\n     * @return {?}\r\n     */\n    get: function get() {\n      return this._value;\n    },\n\n    /**\r\n     * @param {?} val\r\n     * @return {?}\r\n     */\n    set: function set(val) {\n      this._value = coerceNumberProperty(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n\n  NgxGauge.prototype.ngOnChanges = function (changes) {\n    var\n    /** @type {?} */\n    isTextChanged = changes['label'] || changes['append'] || changes['prepend'];\n    var\n    /** @type {?} */\n    isDataChanged = changes['value'] || changes['min'] || changes['max'];\n\n    if (this._initialized) {\n      if (isDataChanged) {\n        var\n        /** @type {?} */\n        nv = void 0,\n\n        /** @type {?} */\n        ov = void 0;\n\n        if (changes['value']) {\n          nv = changes['value'].currentValue;\n          ov = changes['value'].previousValue;\n        }\n\n        this._update(nv, ov);\n      } else if (!isTextChanged) {\n        this._destroy();\n\n        this._init();\n      }\n    }\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._updateSize = function () {\n    this._renderer.setElementStyle(this._elementRef.nativeElement, 'width', cssUnit(this._size));\n\n    this._renderer.setElementStyle(this._elementRef.nativeElement, 'height', cssUnit(this._size));\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype.ngAfterViewInit = function () {\n    if (this._canvas) {\n      this._init();\n    }\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype.ngOnDestroy = function () {\n    this._destroy();\n  };\n  /**\r\n   * @param {?} type\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getBounds = function (type) {\n    var\n    /** @type {?} */\n    head,\n    /** @type {?} */\n    tail;\n\n    if (type == 'semi') {\n      head = Math.PI;\n      tail = 2 * Math.PI;\n    } else if (type == 'full') {\n      head = 1.5 * Math.PI;\n      tail = 3.5 * Math.PI;\n    } else if (type === 'arch') {\n      head = 0.8 * Math.PI;\n      tail = 2.2 * Math.PI;\n    }\n\n    return {\n      head: head,\n      tail: tail\n    };\n  };\n  /**\r\n   * @param {?} start\r\n   * @param {?} middle\r\n   * @param {?} tail\r\n   * @param {?} color\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._drawShell = function (start, middle, tail, color) {\n    var\n    /** @type {?} */\n    center = this._getCenter(),\n\n    /** @type {?} */\n    radius = this._getRadius();\n\n    middle = Math.max(middle, start); // never below 0%\n\n    middle = Math.min(middle, tail); // never exceed 100%\n\n    this._clear();\n\n    this._context.beginPath();\n\n    this._context.strokeStyle = this.backgroundColor;\n\n    this._context.arc(center.x, center.y, radius, middle, tail, false);\n\n    this._context.stroke();\n\n    this._context.beginPath();\n\n    this._context.strokeStyle = color;\n\n    this._context.arc(center.x, center.y, radius, start, middle, false);\n\n    this._context.stroke();\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._clear = function () {\n    this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getWidth = function () {\n    return this.size;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getHeight = function () {\n    return this.size;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getRadius = function () {\n    var\n    /** @type {?} */\n    center = this._getCenter();\n\n    return center.x - this.thick;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getCenter = function () {\n    var\n    /** @type {?} */\n    x = this._getWidth() / 2,\n\n    /** @type {?} */\n    y = this._getHeight() / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._init = function () {\n    this._context = this._canvas.nativeElement.getContext('2d');\n    this._initialized = true;\n\n    this._updateSize();\n\n    this._setupStyles();\n\n    this._create();\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._destroy = function () {\n    if (this._animationRequestID) {\n      window.cancelAnimationFrame(this._animationRequestID);\n      this._animationRequestID = 0;\n    }\n\n    this._clear();\n\n    this._context = null;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._setupStyles = function () {\n    this._context.canvas.width = this.size;\n    this._context.canvas.height = this.size;\n    this._context.lineCap = this.cap;\n    this._context.lineWidth = this.thick;\n  };\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._getForegroundColorByRange = function (value) {\n    var\n    /** @type {?} */\n    match = Object.keys(this.thresholds).filter(function (item) {\n      return isNumber(item) && Number(item) <= value;\n    }).sort(function (a, b) {\n      return Number(a) - Number(b);\n    }).reverse()[0];\n    return match !== undefined ? this.thresholds[match].color || this.foregroundColor : this.foregroundColor;\n  };\n  /**\r\n   * @param {?=} nv\r\n   * @param {?=} ov\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._create = function (nv, ov) {\n    var\n    /** @type {?} */\n    self = this,\n\n    /** @type {?} */\n    type = this.type,\n\n    /** @type {?} */\n    bounds = this._getBounds(type),\n\n    /** @type {?} */\n    duration = this.duration,\n\n    /** @type {?} */\n    min = this.min,\n\n    /** @type {?} */\n    max = this.max,\n\n    /** @type {?} */\n    value = clamp(this.value, this.min, this.max),\n\n    /** @type {?} */\n    start = bounds.head,\n\n    /** @type {?} */\n    unit = (bounds.tail - bounds.head) / (max - min),\n\n    /** @type {?} */\n    displacement = unit * (value - min),\n\n    /** @type {?} */\n    tail = bounds.tail,\n\n    /** @type {?} */\n    color = this._getForegroundColorByRange(value),\n\n    /** @type {?} */\n    startTime;\n\n    if (nv != undefined && ov != undefined) {\n      displacement = unit * nv - unit * ov;\n    }\n    /**\r\n     * @param {?} timestamp\r\n     * @return {?}\r\n     */\n\n\n    function animate(timestamp) {\n      timestamp = timestamp || new Date().getTime();\n      var\n      /** @type {?} */\n      runtime = timestamp - startTime;\n      var\n      /** @type {?} */\n      progress = Math.min(runtime / duration, 1);\n      var\n      /** @type {?} */\n      previousProgress = ov ? ov * unit : 0;\n      var\n      /** @type {?} */\n      middle = start + previousProgress + displacement * progress;\n\n      self._drawShell(start, middle, tail, color);\n\n      if (self._animationRequestID && runtime < duration) {\n        self._animationRequestID = window.requestAnimationFrame(function (timestamp) {\n          return animate(timestamp);\n        });\n      } else {\n        window.cancelAnimationFrame(self._animationRequestID);\n      }\n    }\n\n    self._animationRequestID = window.requestAnimationFrame(function (timestamp) {\n      startTime = timestamp || new Date().getTime();\n      animate(timestamp);\n    });\n  };\n  /**\r\n   * @param {?} nv\r\n   * @param {?} ov\r\n   * @return {?}\r\n   */\n\n\n  NgxGauge.prototype._update = function (nv, ov) {\n    this._clear();\n\n    this._create(nv, ov);\n  };\n\n  return NgxGauge;\n}();\n\nNgxGauge.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'ngx-gauge',\n    template: \"\\n      <div class=\\\"reading-block\\\" #reading [style.fontSize]=\\\"size * 0.22 + 'px'\\\" [style.lineHeight]=\\\"size + 'px'\\\">\\n        <!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 -->\\n        <u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_prependChild != null\\\"><ng-content select=\\\"ngx-gauge-prepend\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{prepend}}</ng-container></u><ng-container [ngSwitch]=\\\"_valueDisplayChild != null\\\"><ng-content *ngSwitchCase=\\\"true\\\" select=\\\"ngx-gauge-value\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{value | number}}</ng-container></ng-container><u class=\\\"reading-affix\\\" [ngSwitch]=\\\"_appendChild != null\\\"><ng-content select=\\\"ngx-gauge-append\\\" *ngSwitchCase=\\\"true\\\"></ng-content><ng-container *ngSwitchCase=\\\"false\\\">{{append}}</ng-container></u>\\n      </div>\\n      <div class=\\\"reading-label\\\" \\n           [style.fontSize]=\\\"size / 13 + 'px'\\\" \\n           [style.lineHeight]=\\\"(5 * size / 13) + size + 'px'\\\" \\n           [ngSwitch]=\\\"_labelChild != null\\\">\\n        <ng-content select=\\\"ngx-gauge-label\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\n        <ng-container *ngSwitchCase=\\\"false\\\">{{label}}</ng-container>\\n      </div>\\n      <canvas #canvas [width]=\\\"size\\\" [height]=\\\"size\\\"></canvas>\\n    \",\n    styles: [\"\\n      .ngx-gauge-meter {\\n          display: inline-block;\\n          text-align: center;\\n          position: relative;\\n      }\\n\\n      .reading-block {\\n          position: absolute;\\n          width: 100%;\\n          font-weight: normal;\\n          white-space: nowrap;\\n          text-align: center;\\n          overflow: hidden;\\n          text-overflow: ellipsis;\\n      }\\n\\n      .reading-label {\\n          font-family: inherit;\\n          width: 100%;\\n          display: inline-block;\\n          position: absolute;\\n          text-align: center;\\n          white-space: nowrap;\\n          overflow: hidden;\\n          text-overflow: ellipsis;\\n          font-weight: normal;\\n      }\\n\\n      .reading-affix {\\n          text-decoration: none;\\n          font-size: 0.6em;\\n          opacity: 0.8;\\n          font-weight: 200;\\n          padding: 0 0.18em;\\n      }\\n\\n      .reading-affix:first-child {\\n          padding-left: 0;\\n      }\\n\\n      .reading-affix:last-child {\\n          padding-right: 0;\\n      }\\n    \"],\n    host: {\n      'role': 'meter',\n      '[class.ngx-gauge-meter]': 'true',\n      '[attr.aria-valuemin]': 'min',\n      '[attr.aria-valuemax]': 'max',\n      '[attr.aria-valuenow]': 'value'\n    },\n    encapsulation: ViewEncapsulation.None\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGauge.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer\n  }];\n};\n\nNgxGauge.propDecorators = {\n  '_canvas': [{\n    type: ViewChild,\n    args: ['canvas']\n  }],\n  '_labelChild': [{\n    type: ContentChild,\n    args: [NgxGaugeLabel]\n  }],\n  '_prependChild': [{\n    type: ContentChild,\n    args: [NgxGaugePrepend]\n  }],\n  '_appendChild': [{\n    type: ContentChild,\n    args: [NgxGaugeAppend]\n  }],\n  '_valueDisplayChild': [{\n    type: ContentChild,\n    args: [NgxGaugeValue]\n  }],\n  'size': [{\n    type: Input\n  }],\n  'min': [{\n    type: Input\n  }],\n  'max': [{\n    type: Input\n  }],\n  'type': [{\n    type: Input\n  }],\n  'cap': [{\n    type: Input\n  }],\n  'thick': [{\n    type: Input\n  }],\n  'label': [{\n    type: Input\n  }],\n  'append': [{\n    type: Input\n  }],\n  'prepend': [{\n    type: Input\n  }],\n  'foregroundColor': [{\n    type: Input\n  }],\n  'backgroundColor': [{\n    type: Input\n  }],\n  'thresholds': [{\n    type: Input\n  }],\n  'value': [{\n    type: Input\n  }],\n  'duration': [{\n    type: Input\n  }]\n};\n\nvar NgxGaugeModule =\n/** @class */\nfunction () {\n  function NgxGaugeModule() {}\n\n  return NgxGaugeModule;\n}();\n\nNgxGaugeModule.decorators = [{\n  type: NgModule,\n  args: [{\n    imports: [CommonModule],\n    declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],\n    exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]\n  }]\n}];\n/**\r\n * @nocollapse\r\n */\n\nNgxGaugeModule.ctorParameters = function () {\n  return [];\n};\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NgxGaugeModule, NgxGauge as ɵa, NgxGaugeAppend as ɵb, NgxGaugeLabel as ɵe, NgxGaugePrepend as ɵc, NgxGaugeValue as ɵd };","map":null,"metadata":{},"sourceType":"module"}