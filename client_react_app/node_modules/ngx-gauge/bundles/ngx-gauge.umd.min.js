!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/common")):"function"==typeof define&&define.amd?define(["exports","@angular/core","@angular/common"],t):t(e["ngx-gauge"]={},e.ng.core,e.ng.common)}(this,function(e,t,n){"use strict";function i(e,t){return void 0===t&&(t=0),isNaN(parseFloat(e))||isNaN(Number(e))?t:Number(e)}function r(e){return e+"px"}var a=function(){return function(){}}();a.decorators=[{type:t.Directive,args:[{selector:"ngx-gauge-append",exportAs:"ngxGaugeAppend"}]}],a.ctorParameters=function(){return[]};var o=function(){return function(){}}();o.decorators=[{type:t.Directive,args:[{selector:"ngx-gauge-prepend",exportAs:"ngxGaugePrepend"}]}],o.ctorParameters=function(){return[]};var s=function(){return function(){}}();s.decorators=[{type:t.Directive,args:[{selector:"ngx-gauge-value",exportAs:"ngxGaugeValue"}]}],s.ctorParameters=function(){return[]};var u=function(){return function(){}}();u.decorators=[{type:t.Directive,args:[{selector:"ngx-gauge-label",exportAs:"ngxGaugeLabel"}]}],u.ctorParameters=function(){return[]};var c={MIN:0,MAX:100,TYPE:"arch",THICK:4,FOREGROUND_COLOR:"rgba(0, 150, 136, 1)",BACKGROUND_COLOR:"rgba(0, 0, 0, 0.1)",CAP:"butt",SIZE:200},l=function(){function e(e,t){this._elementRef=e,this._renderer=t,this._size=c.SIZE,this._min=c.MIN,this._max=c.MAX,this._initialized=!1,this._animationRequestID=0,this.max=c.MAX,this.type=c.TYPE,this.cap=c.CAP,this.thick=c.THICK,this.foregroundColor=c.FOREGROUND_COLOR,this.backgroundColor=c.BACKGROUND_COLOR,this.thresholds=Object.create(null),this._value=0,this.duration=1200}return Object.defineProperty(e.prototype,"size",{get:function(){return this._size},set:function(e){this._size=i(e)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"min",{get:function(){return this._min},set:function(e){this._min=i(e,c.MIN)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"value",{get:function(){return this._value},set:function(e){this._value=i(e)},enumerable:!0,configurable:!0}),e.prototype.ngOnChanges=function(e){var t=e.label||e.append||e.prepend,n=e.value||e.min||e.max;if(this._initialized)if(n){var i=void 0,r=void 0;e.value&&(i=e.value.currentValue,r=e.value.previousValue),this._update(i,r)}else t||(this._destroy(),this._init())},e.prototype._updateSize=function(){this._renderer.setElementStyle(this._elementRef.nativeElement,"width",r(this._size)),this._renderer.setElementStyle(this._elementRef.nativeElement,"height",r(this._size))},e.prototype.ngAfterViewInit=function(){this._canvas&&this._init()},e.prototype.ngOnDestroy=function(){this._destroy()},e.prototype._getBounds=function(e){var t,n;return"semi"==e?(t=Math.PI,n=2*Math.PI):"full"==e?(t=1.5*Math.PI,n=3.5*Math.PI):"arch"===e&&(t=.8*Math.PI,n=2.2*Math.PI),{head:t,tail:n}},e.prototype._drawShell=function(e,t,n,i){var r=this._getCenter(),a=this._getRadius();t=Math.max(t,e),t=Math.min(t,n),this._clear(),this._context.beginPath(),this._context.strokeStyle=this.backgroundColor,this._context.arc(r.x,r.y,a,t,n,!1),this._context.stroke(),this._context.beginPath(),this._context.strokeStyle=i,this._context.arc(r.x,r.y,a,e,t,!1),this._context.stroke()},e.prototype._clear=function(){this._context.clearRect(0,0,this._getWidth(),this._getHeight())},e.prototype._getWidth=function(){return this.size},e.prototype._getHeight=function(){return this.size},e.prototype._getRadius=function(){return this._getCenter().x-this.thick},e.prototype._getCenter=function(){return{x:this._getWidth()/2,y:this._getHeight()/2}},e.prototype._init=function(){this._context=this._canvas.nativeElement.getContext("2d"),this._initialized=!0,this._updateSize(),this._setupStyles(),this._create()},e.prototype._destroy=function(){this._animationRequestID&&(window.cancelAnimationFrame(this._animationRequestID),this._animationRequestID=0),this._clear(),this._context=null},e.prototype._setupStyles=function(){this._context.canvas.width=this.size,this._context.canvas.height=this.size,this._context.lineCap=this.cap,this._context.lineWidth=this.thick},e.prototype._getForegroundColorByRange=function(e){var t=Object.keys(this.thresholds).filter(function(t){return(n=t)!=undefined&&!isNaN(parseFloat(n))&&!isNaN(Number(n))&&Number(t)<=e;var n}).sort(function(e,t){return Number(e)-Number(t)}).reverse()[0];return t!==undefined?this.thresholds[t].color||this.foregroundColor:this.foregroundColor},e.prototype._create=function(e,t){var n,i,r,a,o=this,s=this.type,u=this._getBounds(s),c=this.duration,l=this.min,h=this.max,p=(i=this.value,r=this.min,a=this.max,Math.max(r,Math.min(a,i))),g=u.head,d=(u.tail-u.head)/(h-l),f=d*(p-l),_=u.tail,m=this._getForegroundColorByRange(p);e!=undefined&&t!=undefined&&(f=d*e-d*t);o._animationRequestID=window.requestAnimationFrame(function(e){n=e||(new Date).getTime(),function i(e){var r=(e=e||(new Date).getTime())-n,a=Math.min(r/c,1),s=g+(t?t*d:0)+f*a;o._drawShell(g,s,_,m),o._animationRequestID&&r<c?o._animationRequestID=window.requestAnimationFrame(function(e){return i(e)}):window.cancelAnimationFrame(o._animationRequestID)}(e)})},e.prototype._update=function(e,t){this._clear(),this._create(e,t)},e}();l.decorators=[{type:t.Component,args:[{selector:"ngx-gauge",template:'\n      <div class="reading-block" #reading [style.fontSize]="size * 0.22 + \'px\'" [style.lineHeight]="size + \'px\'">\n        \x3c!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 --\x3e\n        <u class="reading-affix" [ngSwitch]="_prependChild != null"><ng-content select="ngx-gauge-prepend" *ngSwitchCase="true"></ng-content><ng-container *ngSwitchCase="false">{{prepend}}</ng-container></u><ng-container [ngSwitch]="_valueDisplayChild != null"><ng-content *ngSwitchCase="true" select="ngx-gauge-value"></ng-content><ng-container *ngSwitchCase="false">{{value | number}}</ng-container></ng-container><u class="reading-affix" [ngSwitch]="_appendChild != null"><ng-content select="ngx-gauge-append" *ngSwitchCase="true"></ng-content><ng-container *ngSwitchCase="false">{{append}}</ng-container></u>\n      </div>\n      <div class="reading-label" \n           [style.fontSize]="size / 13 + \'px\'" \n           [style.lineHeight]="(5 * size / 13) + size + \'px\'" \n           [ngSwitch]="_labelChild != null">\n        <ng-content select="ngx-gauge-label" *ngSwitchCase="true"></ng-content>\n        <ng-container *ngSwitchCase="false">{{label}}</ng-container>\n      </div>\n      <canvas #canvas [width]="size" [height]="size"></canvas>\n    ',styles:["\n      .ngx-gauge-meter {\n          display: inline-block;\n          text-align: center;\n          position: relative;\n      }\n\n      .reading-block {\n          position: absolute;\n          width: 100%;\n          font-weight: normal;\n          white-space: nowrap;\n          text-align: center;\n          overflow: hidden;\n          text-overflow: ellipsis;\n      }\n\n      .reading-label {\n          font-family: inherit;\n          width: 100%;\n          display: inline-block;\n          position: absolute;\n          text-align: center;\n          white-space: nowrap;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          font-weight: normal;\n      }\n\n      .reading-affix {\n          text-decoration: none;\n          font-size: 0.6em;\n          opacity: 0.8;\n          font-weight: 200;\n          padding: 0 0.18em;\n      }\n\n      .reading-affix:first-child {\n          padding-left: 0;\n      }\n\n      .reading-affix:last-child {\n          padding-right: 0;\n      }\n    "],host:{role:"meter","[class.ngx-gauge-meter]":"true","[attr.aria-valuemin]":"min","[attr.aria-valuemax]":"max","[attr.aria-valuenow]":"value"},encapsulation:t.ViewEncapsulation.None}]}],l.ctorParameters=function(){return[{type:t.ElementRef},{type:t.Renderer}]},l.propDecorators={_canvas:[{type:t.ViewChild,args:["canvas"]}],_labelChild:[{type:t.ContentChild,args:[u]}],_prependChild:[{type:t.ContentChild,args:[o]}],_appendChild:[{type:t.ContentChild,args:[a]}],_valueDisplayChild:[{type:t.ContentChild,args:[s]}],size:[{type:t.Input}],min:[{type:t.Input}],max:[{type:t.Input}],type:[{type:t.Input}],cap:[{type:t.Input}],thick:[{type:t.Input}],label:[{type:t.Input}],append:[{type:t.Input}],prepend:[{type:t.Input}],foregroundColor:[{type:t.Input}],backgroundColor:[{type:t.Input}],thresholds:[{type:t.Input}],value:[{type:t.Input}],duration:[{type:t.Input}]};var h=function(){return function(){}}();h.decorators=[{type:t.NgModule,args:[{imports:[n.CommonModule],declarations:[l,a,o,s,u],exports:[l,a,o,s,u]}]}],h.ctorParameters=function(){return[]},e.NgxGaugeModule=h,e.ɵa=l,e.ɵb=a,e.ɵe=u,e.ɵc=o,e.ɵd=s,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-gauge.umd.min.js.map
